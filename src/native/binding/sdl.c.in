| import * as C from "../codegen/cutils.mjs";
| print = C.print;

#if defined __APPLE__ && defined __MACH__
    #include <SDL2/SDL.h>
#else
    #include "SDL.h"
#endif
#include "quickjs.h"

static JSValue js_SDL_Rect_new(JSContext *ctx, const SDL_Rect *rect) {
    JSValue value = JS_NewObject(ctx);
    if (
        JS_SetPropertyStr(ctx, value, "x", JS_NewInt32(ctx, rect->x)) < 0 ||
        JS_SetPropertyStr(ctx, value, "y", JS_NewInt32(ctx, rect->y)) < 0 ||
        JS_SetPropertyStr(ctx, value, "w", JS_NewInt32(ctx, rect->w)) < 0 ||
        JS_SetPropertyStr(ctx, value, "h", JS_NewInt32(ctx, rect->h)) < 0
    ) {
        JS_FreeValue(ctx, value);
        return JS_EXCEPTION;
    }
    return value;
}

static int js_SDL_Rect_get(JSContext *ctx, SDL_Rect *rect, JSValueConst value) {
    JSValue x, y, w, h;
    if (JS_IsArray(ctx, value)) {
        x = JS_GetPropertyUint32(ctx, value, 0);
        y = JS_GetPropertyUint32(ctx, value, 1);
        w = JS_GetPropertyUint32(ctx, value, 2);
        h = JS_GetPropertyUint32(ctx, value, 3);
    } else {
        x = JS_GetPropertyStr(ctx, value, "x");
        y = JS_GetPropertyStr(ctx, value, "y");
        w = JS_GetPropertyStr(ctx, value, "w");
        h = JS_GetPropertyStr(ctx, value, "h");
    }
    int error =
        JS_ToInt32(ctx, &rect->x, x) < 0 ||
        JS_ToInt32(ctx, &rect->y, y) < 0 ||
        JS_ToInt32(ctx, &rect->w, w) < 0 ||
        JS_ToInt32(ctx, &rect->h, h) < 0;
    JS_FreeValue(ctx, x);
    JS_FreeValue(ctx, y);
    JS_FreeValue(ctx, w);
    JS_FreeValue(ctx, h);
    if (error) return -1;
    return 0;
}

{|
    const SDL_Rect = new class extends C.Type {
        lift(val) {
            let x, y, w, h;
            if (Array.isArray(val)) {
                ([x, y, w, h] = val);
            } else {
                ({x, y, w, h} = val);
            }
            x = Number(x);
            y = Number(y);
            w = Number(w);
            h = Number(h);
            if (x !== x || y !== y || w !== w || h !== h) throw 'invalid SDL_Rect';
            return `(const SDL_Rect){${x}, ${y}, ${w}, ${h}}`;
        }

        toJSValue(ctx, valCode) => `js_SDL_Rect_new(${ctx}, ${valCode})`;

        declareFromJSValue(ctx, name, valCode) {
            print(`SDL_Rect ${name};`);
            print(`if (js_SDL_Rect_get(${ctx}, &${name}, ${valCode}) < 0) return JS_EXCEPTION;`);
	}

	toArgument(name) => `&` + name;
    };
|}

#define countof(x) (sizeof(x) / sizeof((x)[0]))

| let module = new C.Module("sdl");

| let SDL_Event = new C.Opaque(module, "SDL_Event", "", {});
| SDL_Event.prop(C.i32, "type", true);
| SDL_Event.done();

| let SDL_Renderer = new C.Opaque(module, "SDL_Renderer", "*", { finalizer: "SDL_DestroyRenderer" });
| SDL_Renderer.method(C.i32, "SDL_SetRenderDrawColor", "this", "renderer", C.u8, "r", C.u8, "g", C.u8, "b", C.u8, "a");
| SDL_Renderer.method(C.i32, "SDL_RenderClear", "this", "renderer");
| SDL_Renderer.method(C.undef, "SDL_RenderPresent", "this", "renderer");
| SDL_Renderer.method(C.i32, "SDL_RenderDrawPoint", "this", "renderer", C.i32, "x", C.i32, "y");
| SDL_Renderer.method(C.i32, "SDL_RenderDrawLine", "this", "renderer", C.i32, "x1", C.i32, "y1", C.i32, "x2", C.i32, "y2");
| SDL_Renderer.method(C.i32, "SDL_RenderDrawRect", "this", "renderer", SDL_Rect, "rect");
| SDL_Renderer.method(C.i32, "SDL_RenderFillRect", "this", "renderer", SDL_Rect, "rect");
| SDL_Renderer.done();

| let SDL_Window = new C.Opaque(module, "SDL_Window", "*", { finalizer: "SDL_DestroyWindow" });
| SDL_Window.prop(C.u32, "id", "SDL_GetWindowID");
| SDL_Window.method(SDL_Renderer, "SDL_CreateRenderer", "this", "window", C.i32, "index", C.u32, "flags");
| SDL_Window.done();

| module.func(C.bool, "SDL_SetHint", C.char_p, "name", C.char_p, "value");
| module.func(C.i32, "SDL_Init", C.u32, "flags");
| module.func(C.undef, "SDL_Quit", C.u32, "flags");
| module.func(SDL_Window, "SDL_CreateWindow", C.char_p, "title", C.i32, "x", C.i32, "y", C.i32, "w", C.i32, "h", C.u32, "flags"); // return JS_ThrowInternalError(ctx, "%s", SDL_GetError());
| module.func(C.u32, "SDL_GetTicks");
| module.func(C.undef, "SDL_Delay", C.u32, "ms");
| module.const(C.char_p, "SDL_HINT_RENDER_VSYNC");
| module.const(C.i32, "SDL_QUIT");
| module.const(C.i32, "SDL_INIT_VIDEO");
| module.const(C.i32, "SDL_WINDOWPOS_UNDEFINED");
| module.const(C.i32, "SDL_WINDOW_OPENGL");
| module.const(C.i32, "SDL_RENDERER_ACCELERATED");
| module.const(C.i32, "SDL_NUM_SCANCODES");
| module.const(C.i32, "SDL_SCANCODE_UP");
| module.const(C.i32, "SDL_SCANCODE_DOWN");
| module.const(C.i32, "SDL_SCANCODE_LEFT");
| module.const(C.i32, "SDL_SCANCODE_RIGHT");

static JSValue js_sdl_SDL_PollEvent(
    JSContext *ctx,
    JSValueConst this_val,
    int argc,
    JSValueConst *argv
) {
    SDL_Event* event = malloc(sizeof(*event));
    int has_pending_events = SDL_PollEvent(event);
    JS_SetPropertyStr(ctx, argv[0], "current", js_new_sdl_event(ctx, event));
    return JS_NewInt32(ctx, has_pending_events);
}

static JSValue js_sdl_SDL_GetKeyboardState(
    JSContext *ctx,
    JSValueConst this_val,
    int argc,
    JSValueConst *argv
) {
    int numkeys;
    const Uint8* sdl_keyboard_state = SDL_GetKeyboardState(&numkeys);
    if (!JS_IsUndefined(argv[0])) JS_SetPropertyStr(ctx, argv[0], "current", JS_NewInt32(ctx, numkeys));
    return JS_NewArrayBuffer(ctx, (uint8_t *) sdl_keyboard_state, (size_t) numkeys, NULL, NULL, 1);
}

| module.done();

#ifdef JS_SHARED_LIBRARY
#define JS_INIT_MODULE js_init_module
#else
#define JS_INIT_MODULE js_init_module_sdl
#endif

JSModuleDef *JS_INIT_MODULE(JSContext *ctx, const char *module_name)
{
    JSModuleDef *m;
    m = JS_NewCModule(ctx, module_name, js_sdl_init);
    if (!m)
        return NULL;
    JS_AddModuleExportList(ctx, m, js_sdl_funcs, countof(js_sdl_funcs));
    return m;
}
